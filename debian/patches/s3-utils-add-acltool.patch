From 6135ecae5d2509e9bb114d563237ed33ae01b50c Mon Sep 17 00:00:00 2001
From: Andrew Walker <awalker@ixsystems.com>
Date: Tue, 6 Oct 2020 09:36:05 -0400
Subject: [PATCH] Add acltool

Multiplatform acl manipulation tool with pluggable backend.
---
 source3/utils/acltool.c         | 488 +++++++++++++++++++++++++
 source3/utils/acltool.h         |  82 +++++
 source3/utils/acltool_nfs4.c    | 625 ++++++++++++++++++++++++++++++++
 source3/utils/acltool_posix1e.c | 571 +++++++++++++++++++++++++++++
 source3/utils/wscript_build     |  11 +
 5 files changed, 1777 insertions(+)
 create mode 100644 source3/utils/acltool.c
 create mode 100644 source3/utils/acltool.h
 create mode 100644 source3/utils/acltool_nfs4.c
 create mode 100644 source3/utils/acltool_posix1e.c

diff --git a/source3/utils/acltool.c b/source3/utils/acltool.c
new file mode 100644
index 00000000000..a7f074638f2
--- /dev/null
+++ b/source3/utils/acltool.c
@@ -0,0 +1,488 @@
+#include <sys/types.h>
+#include <sys/acl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <err.h>
+#include <fts.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sysexits.h>
+#include <unistd.h>
+#include "acltool.h"
+
+
+struct {
+	const char *str;
+	int action;
+} actions[] = {
+	{	"clone",	WA_CLONE	},
+	{	"strip",	WA_STRIP	},
+	{	"chown",	WA_CHOWN	},
+	{	"restore",	WA_RESTORE	}
+};
+
+size_t actions_size = sizeof(actions) / sizeof(actions[0]);
+
+static int
+get_action(const char *str)
+{
+	int i;
+	int action = WA_NULL;
+
+	for (i = 0;i < actions_size;i++) {
+		if (strcasecmp(actions[i].str, str) == 0) {
+			action = actions[i].action;
+			break;
+		}
+	}
+
+	return action;
+}
+
+
+static struct acl_info *
+new_acl_info(void)
+{
+	struct acl_info *w = NULL;
+	w = calloc(1, sizeof(struct acl_info));
+	if (w == NULL) {
+		err(EX_OSERR, "calloc() failed");
+	}
+	w->acls = calloc(MAX_ACL_DEPTH, sizeof(struct acl_obj));
+	if (w->acls == NULL) {
+		err(EX_OSERR, "calloc() failed");
+	}
+	w->brand = ACL_BRAND_UNKNOWN;
+	w->uid = -1;
+	w->gid = -1;
+
+	return w;
+}
+
+
+static void
+free_acl_info(struct acl_info *w)
+{
+	if (w == NULL)
+		return;
+	int i;
+
+	free(w->source);
+	w->source = NULL;
+	free(w->path);
+	w->path = NULL;
+	if (w->brand != ACL_BRAND_UNKNOWN) {
+		if (w->source_acl != NULL) {
+			w->ops->acl_free_fn(w->source_acl);
+		}
+		for (i=0; i<=MAX_ACL_DEPTH; i++){
+			if (&w->acls[i].is_valid) {
+				w->ops->acl_free_fn(&w->acls[i]);
+			}
+		}
+	}
+	free(w->acls);
+	free(w);
+}
+
+
+static void
+usage(char *path)
+{
+	if (strcmp(path, "cloneacl") == 0) {
+	fprintf(stderr,
+		"Usage: %s [OPTIONS] ...\n"
+		"Where option is:\n"
+		"    -s <path>                    # source for ACL. If none specified then ACL taken from -p\n"
+		"    -p <path>                    # path to recursively set ACL\n"
+		"    -v                           # verbose\n",
+		path
+	);
+	} else {
+	fprintf(stderr,
+		"Usage: %s [OPTIONS] ...\n"
+		"Where option is:\n"
+		"    -a <clone|strip|chown|restore> # action to perform <restore is experimental!>\n"
+		"    -O <owner>                     # change owner\n"
+		"    -G <group>                     # change group\n"
+		"    -c <path>                      # chroot path\n"
+		"    -s <source>                    # source (if cloning ACL). If none specified then ACL taken from -p\n"
+		"    -p <path>                      # path to set\n"
+		"    -r                             # recursive\n"
+		"    -v                             # verbose\n"
+		"    -t                             # trial run - makes no changes\n"
+		"    -x                             # traverse filesystem mountpoints\n"
+		"    -f                             # force acl inheritance\n",
+		path
+	);
+	}
+
+	exit(0);
+}
+
+static inline char *get_relative_path(FTSENT *entry, size_t plen)
+{
+	char *relpath = NULL;
+	relpath = entry->fts_path + plen;
+	if (relpath[0] == '/') {
+		relpath++;
+	}
+	return relpath;
+}
+
+static int
+fts_compare(const FTSENT **s1, const FTSENT **s2)
+{
+	return (strcoll((*s1)->fts_name, (*s2)->fts_name));
+}
+
+static int
+iter_acls(struct acl_info *w)
+{
+	FTS *tree = NULL;
+	FTSENT *entry;
+	int options = 0;
+	char *paths[4];
+	int rval;
+	struct stat ftsroot_st;
+	size_t slen, plen;
+	char *relpath = NULL;
+
+	if (w == NULL)
+		return (-1);
+
+	if (stat(w->path, &ftsroot_st) < 0) {
+		err(EX_OSERR, "%s: stat() failed", w->path);
+	}
+
+	paths[0] = w->path;
+	paths[1] = NULL;
+
+	if ((w->flags & WA_TRAVERSE) == 0 || (w->flags & WA_RESTORE)) {
+		options |= FTS_XDEV;
+	}
+
+	if ((tree = fts_open(paths, options, fts_compare)) == NULL)
+		err(EX_OSERR, "fts_open");
+
+        slen = strlen(w->source);
+        plen = strlen(w->path);
+
+	/* traverse directory hierarchy */
+	for (rval = 0; (entry = fts_read(tree)) != NULL;) {
+		if ((w->flags & WA_RECURSIVE) == 0) {
+			if (entry->fts_level == FTS_ROOTLEVEL){
+				if (w->flags & WA_STRIP) {
+					rval = w->ops->strip_acl_fn(w, entry);
+					break;
+				}
+				rval = w->ops->set_acl_fn(w, entry, w->source_acl, false);
+				break;
+			}
+		}
+
+		/*
+		 * Recursively set permissions for the target path.
+		 * In case FTS_XDEV is set, we still need to check st_dev to avoid
+		 * resetting permissions on subdatasets (FTS_XDEV will only prevent us
+		 * from recursing into directories inside the subdataset.
+		 */
+
+		if ( (options & FTS_XDEV) && (ftsroot_st.st_dev != entry->fts_statp->st_dev) ){
+			continue;
+		}
+
+		switch (entry->fts_info) {
+			case FTS_D:
+			case FTS_F:
+				if (w->root_dev == entry->fts_statp->st_dev) {
+					warnx("%s: path resides in boot pool", entry->fts_path);
+					return -1;
+				}
+				if (w->flags & WA_RESTORE) {
+					relpath = get_relative_path(entry, plen);
+
+					if (strlen(entry->fts_path) > PATH_MAX) {
+						warnx("%s: PATH TOO LONG", entry->fts_path);
+						return -1;
+					}
+					rval = w->ops->restore_acl_fn(w, relpath, entry, slen);
+					break;
+				}
+				if (w->flags & WA_TRIAL) {
+					fprintf(stdout, "depth: %d, name: %s, full_path: %s\n",
+						entry->fts_level, entry->fts_name, entry->fts_path);
+					break;
+				}
+				if (w->flags & WA_STRIP) {
+					rval = w->ops->strip_acl_fn(w, entry);
+				}
+				else if (w->flags & WA_CHOWN) {
+					if ((w->uid == (uid_t)-1 || w->uid == entry->fts_statp->st_uid) &&
+					    (w->gid == (gid_t)-1 || w->gid == entry->fts_statp->st_gid)){
+						continue;
+					}
+					if (chown(entry->fts_accpath, w->uid, w->gid) < 0) {
+						warn("%s: chown() failed", entry->fts_accpath);
+						rval = -1;
+					}
+					if (w->flags & WA_VERBOSE)
+						fprintf(stdout, "%s\n", entry->fts_accpath);
+
+				}
+				else {
+					rval = w->ops->set_acl_fn(w, entry, NULL, false);
+				}
+				break;
+
+			case FTS_ERR:
+				warnx("%s: %s", entry->fts_path, strerror(entry->fts_errno));
+				rval = -2;
+				continue;
+		}
+		if (rval < 0) {
+			err(EX_OSERR, "%s: iter_acls() failed", entry->fts_accpath);
+			continue;
+		}
+
+	} 
+	fts_close(tree);
+
+	return (rval);
+}
+
+
+static void
+usage_check(struct acl_info *w)
+{
+	if (w->path == NULL)
+		errx(EX_USAGE, "no path specified");
+
+	if (!WA_OP_CHECK(w->flags, ~WA_OP_SET) &&
+		w->acls[0].dacl == NULL && w->acls[0].facl == NULL)
+		errx(EX_USAGE, "nothing to do");
+
+}
+
+static uid_t
+id(const char *name, const char *type)
+{
+	uid_t val;
+	char *ep = NULL;
+
+	/*
+	 * We know that uid_t's and gid_t's are unsigned longs.
+	 */
+	errno = 0;
+	val = strtoul(name, &ep, 10);
+	if (errno || *ep != '\0')
+		errx(1, "%s: illegal %s name", name, type);
+	return (val);
+}
+
+static gid_t
+a_gid(const char *s)
+{
+	struct group *gr = NULL;
+	return ((gr = getgrnam(s)) != NULL) ? gr->gr_gid : id(s, "group");
+}
+
+static uid_t
+a_uid(const char *s)
+{
+	struct passwd *pw = NULL;
+	return ((pw = getpwnam(s)) != NULL) ? pw->pw_uid : id(s, "user");
+}
+
+static void set_aclinfo_brand(struct acl_info *w) {
+#if HAS_NFS4_ACLS
+	if (pathconf(w->source, _PC_ACL_NFS4) < 0) {
+		posix1e_acl_ops_init(w);
+	}
+	else {
+		nfs4_acl_ops_init(w);
+	}
+#else
+	posix1e_acl_ops_init(w);
+#endif
+}
+
+int
+main(int argc, char **argv)
+{
+	int 	ch, ret;
+	ch = ret = 0;
+	struct stat st;
+	struct acl_info *w = NULL;
+	FTSENT fake_ftsent;
+	ZERO_STRUCT(fake_ftsent);
+	if (argc < 2) {
+		usage(argv[0]);
+	}
+	w = new_acl_info();
+
+	while ((ch = getopt(argc, argv, "a:O:G:c:s:p:rftvx")) != -1) {
+		switch (ch) {
+			case 'a': {
+				int action = get_action(optarg);
+				if (action == WA_NULL)
+					errx(EX_USAGE, "invalid action");
+				if (WA_OP_CHECK(w->flags, action))
+					errx(EX_USAGE, "only one action can be specified");
+				w->flags |= action;
+				break;
+			}
+
+			case 'O': {
+				w->uid = a_uid(optarg);
+				break;
+			}
+
+			case 'G': {
+				w->gid = a_gid(optarg);
+				break;
+			}
+
+			case 'c':
+				w->chroot = realpath(optarg, NULL);
+				break;
+
+			case 's':
+				w->source = realpath(optarg, NULL);
+				break;
+
+			case 'p':
+				w->path = realpath(optarg, NULL);
+				break;
+
+			case 'r':
+				w->flags |= WA_RECURSIVE;
+				break;
+
+			case 't':
+				w->flags |= WA_TRIAL;
+				break;
+
+			case 'v':
+				w->flags |= WA_VERBOSE;
+				break;
+
+			case 'x':
+				w->flags |= WA_TRAVERSE;
+				break;
+
+			case 'f':
+				w->flags |= WA_FORCE;
+				break;
+
+			case '?':
+			default:
+				usage(argv[0]);
+			}
+	}
+
+	if (w->path == NULL) {
+		errno = EINVAL;
+		warn("Path [-p] must be specified");
+		usage(argv[0]);
+	}
+
+	/* set the source to the destination if we lack -s */
+	if (w->source == NULL) {
+		if (w->flags & WA_RESTORE) {
+			warn("source must be set for restore jobs");
+			return (1);
+		}
+		w->source = strdup(w->path);
+		if (w->source == NULL) {
+			warn("failed to duplicate path name");
+			return (1);
+		}
+	}
+
+	if (stat("/", &st) < 0) {
+		warn("%s: stat() failed.", "/");
+		return (1);
+	}
+	w->root_dev = st.st_dev;
+	w->st = st;
+
+	if (w->chroot != NULL) {
+		if (w->source != NULL) {
+			if (strncmp(w->chroot, w->source, strlen(w->chroot)) != 0) {
+				warn("%s: path does not lie in chroot path.", w->source);
+				free_acl_info(w);
+				return (1);
+			}
+			w->source += strlen(w->chroot);
+		}
+		if (w->path != NULL ) {
+			if (strncmp(w->chroot, w->path, strlen(w->chroot)) != 0) {
+				warn("%s: path does not lie in chroot path.", w->path);
+				free_acl_info(w);
+				return (1);
+			}
+			w->path += strlen(w->chroot);
+		}
+		ret = chdir(w->chroot);
+		if (ret == -1) {
+			warn("%s: chdir() failed.", w->chroot);
+			free_acl_info(w);
+			return (1);
+		}
+		ret = chroot(w->chroot);
+		if (ret == -1) {
+			warn("%s: chroot() failed.", w->chroot);
+			free_acl_info(w);
+			return (1);
+		}
+		if (access(w->path, F_OK) < 0) {
+			warn("%s: access() failed after chroot.", w->source);
+			free_acl_info(w);
+			return (1);
+		}
+	}
+
+	if (access(w->source, F_OK) < 0) {
+		warn("%s: access() failed.", w->source);
+		free_acl_info(w);
+		return (1);
+	}
+
+	set_aclinfo_brand(w);
+
+	if (w->flags & WA_CLONE){
+		fake_ftsent.fts_path = w->source;
+		fake_ftsent.fts_statp = &w->st;
+		w->source_acl = w->ops->get_acl_fn(w, &fake_ftsent, false);
+		if (w->source_acl == NULL) {
+			err(EX_OSERR, "%s: acl_get_file() failed", w->source);
+			free_acl_info(w);
+			return (1);
+		}
+
+		ret = w->ops->calculate_inherited_acl_fn(w, w->source_acl, 0);
+		if (ret != 0) {
+			free_acl_info(w);
+			return (1);
+		}
+		ret = w->ops->calculate_inherited_acl_fn(w, &w->acls[0], 1);
+		if (ret != 0) {
+			free_acl_info(w);
+			return (1);
+		}
+	}
+
+	usage_check(w);
+
+	if (iter_acls(w) <0) {
+		ret = 1;
+	}
+
+	free_acl_info(w);
+	return (ret);
+}
diff --git a/source3/utils/acltool.h b/source3/utils/acltool.h
new file mode 100644
index 00000000000..67c33d284cc
--- /dev/null
+++ b/source3/utils/acltool.h
@@ -0,0 +1,82 @@
+#include <sys/types.h>
+#include <sys/acl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <err.h>
+#include <fts.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sysexits.h>
+#include <unistd.h>
+#ifdef __linux__
+#include <linux/limits.h>
+#endif
+
+
+#define	WA_NULL			0x00000000	/* nothing */
+#define	WA_RECURSIVE		0x00000001	/* recursive */
+#define	WA_VERBOSE		0x00000002	/* print more stuff */
+#define	WA_CLONE		0x00000008	/* clone an ACL */
+#define	WA_TRAVERSE		0x00000010	/* traverse filesystem mountpoints */
+#define	WA_PHYSICAL		0x00000020	/* do not follow symlinks */
+#define	WA_STRIP		0x00000040	/* strip ACL */
+#define	WA_CHOWN		0x00000080	/* only chown */
+#define	WA_TRIAL		0x00000100	/* trial run */
+#define	WA_RESTORE		0x00000200	/* restore ACL */
+#define	WA_FORCE		0x00000400	/* force */
+
+#define	WA_OP_SET	(WA_CLONE|WA_STRIP|WA_CHOWN|WA_RESTORE)
+#define	WA_OP_CHECK(flags, bit) ((flags & ~bit) & WA_OP_SET)
+#define	MAX_ACL_DEPTH		2
+#define ISDIR(x)(x->fts_statp->st_mode & S_IFDIR)
+#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))
+
+// FreeBSD acl_type_t arguments
+#define ACL_TOOL_ACCESS		0x00000002
+#define ACL_TOOL_DEFAULT	0x00000003
+#define ACL_TOOL_NFSV4		0x00000004
+
+enum aclbrand { ACL_BRAND_UNKNOWN, ACL_BRAND_POSIX1E, ACL_BRAND_NFSV4 };
+
+struct acl_obj {	
+	void *dacl; /*NFSV4 directory ACL or POSIX1e DEFAULT ACL*/
+	void *facl; /*NFSV4 file ACL or POSIX1e ACCESS ACL*/
+	bool is_valid;
+	bool is_alloc;
+};
+
+struct acl_info;
+
+struct acl_ops {
+	int (*restore_acl_fn)(struct acl_info *w, char *relpath, FTSENT *fts_entry, size_t slen);
+	int (*calculate_inherited_acl_fn)(struct acl_info *w, struct acl_obj *parent_acl, int depth);
+	int (*set_acl_fn)(struct acl_info *w, FTSENT *fts_entry, struct acl_obj *to_set, bool quiet);
+	struct acl_obj *(*get_acl_fn)(struct acl_info *w, FTSENT *fts_entry, bool quiet);
+	int (*get_acl_parent_fn)(struct acl_info *w, FTSENT *fts_entry);
+	int (*strip_acl_fn)(struct acl_info *w, FTSENT *fts_entry);
+	int (*acl_cmp_fn)(struct acl_obj source, struct acl_obj dest, int flags);
+	void (*acl_free_fn)(struct acl_obj *tofree);
+};
+
+struct acl_info {
+	char *source;
+	char *path;
+	char *chroot;
+	long pathmax;
+	struct acl_obj *source_acl;
+	dev_t root_dev;
+	struct stat st;
+	struct acl_obj *acls;
+	uid_t uid;
+	gid_t gid;
+	int	flags;
+	const struct acl_ops *ops;
+	enum aclbrand brand;
+};
+
+void nfs4_acl_ops_init(struct acl_info *w);
+void posix1e_acl_ops_init(struct acl_info *w);
diff --git a/source3/utils/acltool_nfs4.c b/source3/utils/acltool_nfs4.c
new file mode 100644
index 00000000000..76945481c86
--- /dev/null
+++ b/source3/utils/acltool_nfs4.c
@@ -0,0 +1,625 @@
+#include <sys/types.h>
+#include <sys/acl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <err.h>
+#include <fts.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sysexits.h>
+#include <unistd.h>
+#include "acltool.h"
+
+static const struct acl_ops nfs4_acl_ops;
+
+void nfs4_acl_ops_init(struct acl_info *w) 
+{
+	w->ops = &nfs4_acl_ops;
+}
+
+#ifdef HAS_NFS4_ACLS 
+int
+strip_acl_nfs4(struct acl_info *w, FTSENT *fts_entry)
+{
+	/*
+	 * Convert non-trivial ACL to trivial ACL.
+	 * This function is only called when action is set
+	 * to 'strip'. A trivial ACL is one that is fully
+	 * represented by the posix mode. If the goal is to
+	 * simply remove ACLs, it will generally be more
+	 * efficient to strip the ACL using setfacl -b
+	 * from the root directory and then use the 'clone'
+	 * action to set the ACL recursively.
+	 */
+	char *path;
+	acl_t acl_tmp, acl_new;
+
+	if (fts_entry == NULL)
+		path = w->path;
+	else
+		path = fts_entry->fts_accpath;
+
+	if (w->flags & WA_VERBOSE)
+		fprintf(stdout, "%s\n", path);
+	acl_tmp = acl_get_file(path, ACL_TYPE_NFS4);
+	if (acl_tmp == NULL) {
+		warn("%s: acl_get_file() failed", path);
+		return (-1);
+	}
+	acl_new = acl_strip_np(acl_tmp, 0);
+	if (acl_new == NULL) {
+		warn("%s: acl_strip_np() failed", path);
+		acl_free(acl_tmp);
+		return (-1);
+	}
+
+	if (acl_set_file(path, ACL_TYPE_NFS4, acl_new) < 0) {
+		warn("%s: acl_set_file() failed", path);
+		acl_free(acl_tmp);
+		acl_free(acl_new);
+		return (-1);
+	}
+	acl_free(acl_tmp);
+	acl_free(acl_new);
+
+	if (w->uid != -1 || w->gid != -1) {
+		if (chown(path, w->uid, w->gid) < 0) {
+			warn("%s: chown() failed", path);
+			return (-1);
+		}
+	}
+	return (0);
+}
+
+/*
+ * Iterate through linked list of parent directories until we are able
+ * to find one that exists in the snapshot directory. Use this ACL
+ * to calculate an inherited acl.
+ */
+int get_acl_parent_nfs4(struct acl_info *w, FTSENT *fts_entry)
+{
+	int rval;
+	FTSENT *p = NULL;
+	char *path = NULL;
+	char *relpath = NULL;
+	size_t plen, slen;
+	char shadow_path[PATH_MAX] = {0};
+	acl_t parent_acl;
+
+	plen = strlen(w->path);
+	slen = strlen(w->source);
+
+	if (fts_entry->fts_parent == NULL) {
+		/*
+		 * No parent node indicates we're at fts root level.
+		 */
+		parent_acl = acl_get_file(w->source, ACL_TYPE_NFS4);
+		if (parent_acl == NULL) {
+			return -1;
+		}
+		rval = calculate_inherited_acl(w, parent_acl, 0);
+		if (rval != 0) {
+			warn("%s: acl_get_file() failed", w->source);
+		}
+		acl_free(parent_acl);
+		return rval;
+	}
+
+	for (p=fts_entry->fts_parent; p; p=p->fts_parent) {
+		rval = snprintf(shadow_path, sizeof(shadow_path),
+				"%s/%s", w->source, p->fts_accpath);
+		if (rval < 0) {
+			warn("%s: snprintf failed", relpath);
+			return -1;
+		}
+
+		parent_acl = acl_get_file(shadow_path, ACL_TYPE_NFS4);
+		if (parent_acl == NULL) {
+			if (errno == ENOENT) {
+				continue;
+			}
+			else {
+				warn("%s: acl_get_file() failed", shadow_path);
+				return -1;
+
+			}
+		}
+
+		rval = calculate_inherited_acl(w, parent_acl, 0);
+		if (rval == 0) {
+			acl_free(parent_acl);
+			return 0;
+		}
+		warn("%s: acl_get_file() failed", shadow_path);
+		acl_free(parent_acl);
+	}
+	return -1;
+}
+
+/*
+ * Compare two acl_t structs. Return 0 on success -1 on failure.
+ */
+inline int acl_cmp_nfs4(acl_t source, acl_t dest, int flags)
+{
+	acl_entry_t s_entry, p_entry;
+	acl_permset_t s_perm, p_perm;
+	acl_tag_t s_tag, p_tag;
+	acl_flagset_t s_flag, p_flag;
+
+	int entry_id = ACL_FIRST_ENTRY;
+	int rv;
+
+	if (source->ats_acl.acl_cnt != dest->ats_acl.acl_cnt) {
+		if (flags & WA_VERBOSE) {
+			fprintf(stdout, "+ [COUNT %d -> %d] ",
+				source->ats_acl.acl_cnt,
+				dest->ats_acl.acl_cnt);
+		}
+		return -1;
+	}
+
+	while (acl_get_entry(source, entry_id, &s_entry) == 1) {
+		entry_id = ACL_NEXT_ENTRY;
+		rv = acl_get_entry(dest, entry_id, &p_entry);
+		if (rv != 1) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL_ERROR: %s] ",
+					strerror(errno));
+			}
+			return -1;
+		}
+
+		if (s_entry->ae_tag != p_entry->ae_tag) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL tag 0x%08x -> 0x%08x] ",
+					s_entry->ae_tag, p_entry->ae_tag);
+			}
+			return -1;
+		}
+		if (s_entry->ae_id != p_entry->ae_id) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL id %d -> %d] ",
+					s_entry->ae_id, p_entry->ae_id);
+			}
+			return -1;
+		}
+		if (s_entry->ae_perm != p_entry->ae_perm) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL perm 0x%08x -> 0x%08x] ",
+					s_entry->ae_perm, p_entry->ae_perm);
+			}
+			return -1;
+		}
+		if (s_entry->ae_entry_type != p_entry->ae_entry_type) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL entry_type 0x%08x -> 0x%08x] ",
+					s_entry->ae_entry_type, p_entry->ae_entry_type);
+			}
+			return -1;
+		}
+		if (s_entry->ae_flags != p_entry->ae_flags) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL entry_flags 0x%08x -> 0x%08x] ",
+					s_entry->ae_flags, p_entry->ae_flags);
+			}
+			return -1;
+		}
+	}
+	return 0;
+}
+
+
+int
+restore_acl_nfs4(struct acl_info *w, char *relpath, FTSENT *fts_entry, size_t slen)
+{
+	int rval;
+	acl_t acl_new, acl_old;
+	char shadow_path[PATH_MAX] = {0};
+
+	if (strlen(relpath) + slen > PATH_MAX) {
+		warn("%s: path in snapshot directory is too long", relpath);
+		return -1;
+	}
+
+	rval = snprintf(shadow_path, sizeof(shadow_path), "%s/%s", w->source, relpath);
+	if (rval < 0) {
+		warn("%s: snprintf failed", relpath);
+		return -1;
+	}
+
+	acl_new = acl_get_file(shadow_path, ACL_TYPE_NFS4);
+	if (acl_new == NULL) {
+		if (errno == ENOENT) {
+			if (w->flags & WA_FORCE) {
+				rval = get_acl_parent(w, fts_entry);
+				if (rval != 0) {
+					fprintf(stdout, "! %s\n", shadow_path);
+					return 0;
+				}
+				acl_new = acl_dup(((fts_entry->fts_statp->st_mode & S_IFDIR) == 0) ? w->acls[0].facl : w->acls[0].dacl);
+				if (acl_new == NULL) {
+					warn("%s: acl_dup() failed", shadow_path);
+					return -1;
+				}
+			}
+			else {
+				fprintf(stdout, "! %s\n", shadow_path);
+				return 0;
+			}
+		}
+		else {
+			warn("%s: acl_get_file() failed", shadow_path);
+			return (-1);
+		}
+	}
+
+	acl_old = acl_get_file(fts_entry->fts_path, ACL_TYPE_NFS4);
+	if (acl_old == NULL) {
+		warn("%s: acl_get_file() failed", fts_entry->fts_path);
+		return (-1);
+	}
+
+	rval = acl_cmp(acl_new, acl_old, w->flags);
+	if (rval == 0) {
+		return 0;
+	}
+
+	if (w->flags & WA_VERBOSE) {
+		fprintf(stdout, "%s -> %s\n",
+			shadow_path,
+			fts_entry->fts_path);
+	}
+	if ((w->flags & WA_TRIAL) == 0) {
+		rval = acl_set_file(fts_entry->fts_accpath,
+				    ACL_TYPE_NFS4, acl_new);
+		if (rval < 0) {
+			warn("%s: acl_set_file() failed", fts_entry->fts_accpath);
+			acl_free(acl_old);
+			acl_free(acl_new);
+			return -1;
+		}
+	}
+
+	acl_free(acl_old);
+	acl_free(acl_new);
+	return 0;
+}
+
+int
+set_acl_nfs4(struct acl_info *w, FTSENT *fts_entry)
+{
+	char *path = NULL;
+	acl_t acl_new;
+	int acl_depth = 0;
+
+	if (w->flags & WA_VERBOSE) {
+		fprintf(stdout, "%s\n", fts_entry->fts_path);
+	}
+
+	/* don't set inherited flag on root dir. This is required for zfsacl:map_dacl_protected */
+	if (fts_entry->fts_level == FTS_ROOTLEVEL) {
+		acl_new = w->source_acl;
+	}
+	else {
+		if ((fts_entry->fts_level -1) >= MAX_ACL_DEPTH) {
+			acl_depth = MAX_ACL_DEPTH-1;
+		}
+		else {
+			acl_depth = fts_entry->fts_level -1;
+		}
+		acl_new = ((fts_entry->fts_statp->st_mode & S_IFDIR) == 0) ? w->acls[acl_depth].facl : w->acls[acl_depth].dacl;
+	}
+
+	/* write out the acl to the file */
+	if (acl_set_file(fts_entry->fts_accpath, ACL_TYPE_NFS4, acl_new) < 0) {
+		warn("%s: acl_set_file() failed", path);
+		return (-1);
+	}
+
+	if (w->uid != -1 || w->gid != -1) {
+		if (chown(path, w->uid, w->gid) < 0) {
+			warn("%s: chown() failed", path);
+			return (-1);
+		}
+	}
+
+ 
+	return (0);
+}
+
+
+static int
+fts_compare(const FTSENT * const *s1, const FTSENT * const *s2)
+{
+	return (strcoll((*s1)->fts_name, (*s2)->fts_name));
+}
+
+
+
+static int
+set_acls(struct acl_info *w)
+{
+	FTS *tree = NULL;
+	FTSENT *entry;
+	int options = 0;
+	char *paths[4];
+	int rval;
+	struct stat ftsroot_st;
+	size_t slen, plen;
+	char *relpath = NULL;
+
+	if (w == NULL)
+		return (-1);
+
+	if (stat(w->path, &ftsroot_st) < 0) {
+		err(EX_OSERR, "%s: stat() failed", w->path);
+	}
+
+	paths[0] = w->path;
+	paths[1] = NULL;
+
+	if ((w->flags & WA_TRAVERSE) == 0 || (w->flags & WA_RESTORE)) {
+		options |= FTS_XDEV;
+	}
+
+	if ((tree = fts_open(paths, options, fts_compare)) == NULL)
+		err(EX_OSERR, "fts_open");
+
+        slen = strlen(w->source);
+        plen = strlen(w->path);
+
+	/* traverse directory hierarchy */
+	for (rval = 0; (entry = fts_read(tree)) != NULL;) {
+		if ((w->flags & WA_RECURSIVE) == 0) {
+			if (entry->fts_level == FTS_ROOTLEVEL){
+				rval = set_acl(w, entry);
+				break;
+			}
+		}
+
+		/*
+		 * Recursively set permissions for the target path.
+		 * In case FTS_XDEV is set, we still need to check st_dev to avoid
+		 * resetting permissions on subdatasets (FTS_XDEV will only prevent us
+		 * from recursing into directories inside the subdataset.
+		 */
+
+		if ( (options & FTS_XDEV) && (ftsroot_st.st_dev != entry->fts_statp->st_dev) ){
+			continue;
+		}
+
+		switch (entry->fts_info) {
+			case FTS_D:
+			case FTS_F:
+				if (w->root_dev == entry->fts_statp->st_dev) {
+					warnx("%s: path resides in boot pool", entry->fts_path);
+					return -1;
+				}
+				if (w->flags & WA_RESTORE) {
+					relpath = get_relative_path(entry, plen);
+
+					if (strlen(entry->fts_path) > PATH_MAX) {
+						warnx("%s: PATH TOO LONG", entry->fts_path);
+						return -1;
+					}
+					rval = restore_acl(w, relpath, entry, slen);
+					break;
+				}
+				if (w->flags & WA_TRIAL) {
+					fprintf(stdout, "depth: %ld, name: %s, full_path: %s\n",
+						entry->fts_level, entry->fts_name, entry->fts_path);
+					break;
+				}
+				if (w->flags & WA_STRIP) {
+					rval = strip_acl(w, entry);
+				}
+				else if (w->flags & WA_CHOWN) {
+					if ((w->uid == (uid_t)-1 || w->uid == entry->fts_statp->st_uid) &&
+					    (w->gid == (gid_t)-1 || w->gid == entry->fts_statp->st_gid)){
+						continue;
+					}
+					if (chown(entry->fts_accpath, w->uid, w->gid) < 0) {
+						warn("%s: chown() failed", entry->fts_accpath);
+						rval = -1;
+					}
+					if (w->flags & WA_VERBOSE)
+						fprintf(stdout, "%s\n", entry->fts_accpath);
+
+				}
+				else {
+					rval = set_acl(w, entry);
+				}
+				break;
+
+			case FTS_ERR:
+				warnx("%s: %s", entry->fts_path, strerror(entry->fts_errno));
+				rval = -2;
+				continue;
+		}
+		if (rval < 0) {
+			err(EX_OSERR, "%s: set_acl() failed", entry->fts_accpath);
+			continue;
+		}
+
+	} 
+
+	return (rval);
+}
+
+int
+calculate_inherited_acl_nfs4(struct acl_info *w, acl_t parent_acl, int level)
+{
+	/*
+	 * Generates an inherited directory ACL and file ACL based
+	 * on the ACL specified in the parent_acl. Behavior in the absence of
+	 * inheriting aces in the parent ACL is as follows: if the parent_acl
+	 * is trivial (i.e. can be expressed as posix mode without
+	 * information loss), then apply the mode recursively. If the ACL
+	 * is non-trivial, then user intention is less clear and so error
+	 * out.
+	 *
+	 * Currently, nfsv41 inheritance is not implemented.
+	 */
+	int trivial = 0;
+	acl_t tmp_acl;
+	acl_entry_t entry, file_entry, dir_entry;
+	acl_permset_t permset;
+	acl_flagset_t flagset, file_flag, dir_flag;
+	int entry_id, f_entry_id, d_entry_id, must_set_facl, must_set_dacl;
+	int ret = 0;
+	entry_id = f_entry_id = d_entry_id = ACL_FIRST_ENTRY;
+	must_set_facl = must_set_dacl = true;
+
+	if (w->acls[level].dacl != NULL) {
+		acl_free(w->acls[level].dacl);
+	}
+	if (w->acls[level].facl != NULL) {
+		acl_free(w->acls[level].facl);
+	}
+	/*
+	 * Short-circuit for trivial ACLs. If ACL is trivial,
+	 * assume that user does not want to apply ACL inheritance rules.
+	 */
+	if (acl_is_trivial_np(parent_acl, &trivial) != 0) {
+		err(EX_OSERR, "acl_is_trivial_np() failed");
+	}
+	if (trivial) {
+		w->acls[level].dacl = acl_dup(parent_acl);
+		w->acls[level].facl = acl_dup(parent_acl);
+		return ret;
+	}
+
+	/* initialize separate directory and file ACLs */
+	if ((w->acls[level].dacl = acl_init(ACL_MAX_ENTRIES)) == NULL) {
+		err(EX_OSERR, "failed to initialize directory ACL");
+	}
+	if ((w->acls[level].facl = acl_init(ACL_MAX_ENTRIES)) == NULL) {
+		err(EX_OSERR, "failed to initialize file ACL");
+	}
+
+	tmp_acl = acl_dup(parent_acl);
+
+	if (tmp_acl == NULL) {
+		err(EX_OSERR, "acl_dup() failed");
+	}
+
+	while (acl_get_entry(tmp_acl, entry_id, &entry) == 1) {
+		entry_id = ACL_NEXT_ENTRY;
+		if (acl_get_permset(entry, &permset)) {
+			err(EX_OSERR, "acl_get_permset() failed");
+		}
+		if (acl_get_flagset_np(entry, &flagset)) {
+			err(EX_OSERR, "acl_get_flagset_np() failed");
+		}
+
+		/* Entry is not inheritable at all. Skip. */
+		if ((*flagset & (ACL_ENTRY_DIRECTORY_INHERIT|ACL_ENTRY_FILE_INHERIT)) == 0) {
+			continue;
+		}
+
+		/* Skip if the ACE has NO_PROPAGATE flag set and does not have INHERIT_ONLY flag. */
+		if ((*flagset & ACL_ENTRY_NO_PROPAGATE_INHERIT) &&
+		    (*flagset & ACL_ENTRY_INHERIT_ONLY) == 0) {
+			continue;
+		}
+
+		/*
+		 * By the time we've gotten here, we're inheriting something somewhere.
+		 * Strip inherit only from the flagset and set ACL_ENTRY_INHERITED.
+		 */
+
+		*flagset &= ~ACL_ENTRY_INHERIT_ONLY;
+		*flagset |= ACL_ENTRY_INHERITED;
+
+		if ((*flagset & ACL_ENTRY_FILE_INHERIT) == 0) {
+			must_set_facl = false;
+		}
+
+		/*
+		 * Add the entries to the file ACL and directory ACL. Since files and directories
+		 * will require differnt flags to be set, we make separate calls to acl_get_flagset_np()
+		 * to modify the flagset of the new ACEs.
+		 */
+		if (must_set_facl) {
+			if (acl_create_entry_np(&w->acls[level].facl, &file_entry, f_entry_id) == -1) {
+				err(EX_OSERR, "acl_create_entry() failed");
+			}
+			if (acl_copy_entry(file_entry, entry) == -1) {
+				err(EX_OSERR, "acl_create_entry() failed");
+			}
+			if (acl_get_flagset_np(file_entry, &file_flag)) {
+				err(EX_OSERR, "acl_get_flagset_np() failed");
+			}
+			*file_flag &= ~(ACL_ENTRY_DIRECTORY_INHERIT|ACL_ENTRY_FILE_INHERIT|ACL_ENTRY_NO_PROPAGATE_INHERIT);
+			f_entry_id ++;
+		}
+		if (must_set_dacl) {
+			if (acl_create_entry_np(&w->acls[level].dacl, &dir_entry, d_entry_id) == -1) {
+				err(EX_OSERR, "acl_create_entry() failed");
+			}
+			if (acl_copy_entry(dir_entry, entry) == -1) {
+				err(EX_OSERR, "acl_create_entry() failed");
+			}
+			if (acl_get_flagset_np(dir_entry, &dir_flag)) {
+				err(EX_OSERR, "acl_get_flagset_np() failed");
+			}
+			/*
+			 * Special handling for NO_PROPAGATE_INHERIT. Original flags at
+			 * this point would have been fdin, din, or fin. In the case of
+			 * fin, the acl entry must not be added to the dacl (since it only
+			 * applies to files).
+			 */
+			if (*flagset & ACL_ENTRY_NO_PROPAGATE_INHERIT) {
+				if ((*flagset & ACL_ENTRY_DIRECTORY_INHERIT) == 0) {
+					continue;
+				}
+				*dir_flag &= ~(ACL_ENTRY_DIRECTORY_INHERIT|ACL_ENTRY_FILE_INHERIT|ACL_ENTRY_NO_PROPAGATE_INHERIT);
+			}
+			/*
+			 * If only FILE_INHERIT is set then turn on INHERIT_ONLY
+			 * on directories. This is to prevent ACE from applying to directories.
+			 */
+			else if ((*flagset & ACL_ENTRY_DIRECTORY_INHERIT) == 0) {
+				*dir_flag |= ACL_ENTRY_INHERIT_ONLY;
+			}
+			d_entry_id ++;
+		}
+		must_set_dacl = must_set_facl = true;
+
+	}
+	acl_free(tmp_acl);
+	if ( d_entry_id == 0 || f_entry_id == 0 ) {
+		errno = EINVAL;
+		warn("%s: acl_set_file() failed. Calculated invalid ACL with no inherited entries.", w->source);
+		ret = -1;
+	}
+	return (ret);
+}
+static const struct acl_ops nfs4_acl_ops = {
+        .restore_acl_fn = restore_acl_nfs,
+        .calculate_inherited_acl_fn = cacluate_inherited_acl_nfs4,
+        .set_acl_fn = set_acl_nfs4,
+        .get_acl_fn = get_acl_nfs4,
+        .get_acl_parent_fn = get_acl_parent_nfs4,
+        .strip_acl_fn = strip_acl_nfs4,
+        .acl_cmp_fn = acl_cmp_nfs4,
+        .acl_free_fn = acl_free_nfs4,
+
+};
+#else
+static const struct acl_ops nfs4_acl_ops = {
+        .restore_acl_fn = NULL,
+        .calculate_inherited_acl_fn = NULL,
+        .set_acl_fn = NULL,
+        .get_acl_fn = NULL,
+        .get_acl_parent_fn = NULL,
+        .strip_acl_fn = NULL,
+        .acl_cmp_fn = NULL,
+        .acl_free_fn = NULL,
+
+};
+#endif
diff --git a/source3/utils/acltool_posix1e.c b/source3/utils/acltool_posix1e.c
new file mode 100644
index 00000000000..20c3c0a2460
--- /dev/null
+++ b/source3/utils/acltool_posix1e.c
@@ -0,0 +1,571 @@
+#include <sys/types.h>
+#include <sys/acl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <err.h>
+#include <fts.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sysexits.h>
+#include <unistd.h>
+#include "acltool.h"
+#ifdef __linux__
+#include <acl/libacl.h>
+#endif
+
+
+/* from POSIX1e setfacl in acl package */
+static const struct acl_ops posix1e_acl_ops;
+
+void posix1e_acl_ops_init(struct acl_info *w)
+{
+	w->ops = &posix1e_acl_ops;
+	w->brand = ACL_BRAND_POSIX1E;
+}
+
+#ifdef __linux__
+int
+acl_get_perm_np(acl_permset_t permset_d, acl_perm_t perm)
+{
+	return acl_get_perm(permset_d, perm);
+}
+#endif
+
+acl_entry_t
+find_entry(
+        acl_t acl,
+        acl_tag_t type,
+        id_t id)
+{
+        acl_entry_t ent;
+        acl_tag_t e_type;
+        id_t *e_id_p;
+
+        if (acl_get_entry(acl, ACL_FIRST_ENTRY, &ent) != 1){
+                return NULL;
+	}
+
+        for(;;) {
+                acl_get_tag_type(ent, &e_type);
+                if (type == e_type) {
+                        if (id != ACL_UNDEFINED_ID) {
+                                e_id_p = acl_get_qualifier(ent);
+                                if (e_id_p == NULL)
+                                        return NULL;
+                                if (*e_id_p == id) {
+                                        acl_free(e_id_p);
+                                        return ent;
+                                }
+                                acl_free(e_id_p);
+                        } else {
+                                return ent;
+                        }
+                }
+                if (acl_get_entry(acl, ACL_NEXT_ENTRY, &ent) != 1)
+                        return NULL;
+        }
+}
+
+
+static int
+remove_extended_entries(
+	acl_t acl)
+{
+	acl_entry_t ent, group_obj;
+	acl_permset_t mask_permset, group_obj_permset;
+	acl_tag_t tag;
+	int error;
+
+	ent = find_entry(acl, ACL_MASK, ACL_UNDEFINED_ID);
+	group_obj = find_entry(acl, ACL_GROUP_OBJ, ACL_UNDEFINED_ID);
+	if (ent && group_obj) {
+		if (!acl_get_permset(ent, &mask_permset) &&
+		    !acl_get_permset(group_obj, &group_obj_permset)) {
+			if (!acl_get_perm_np(mask_permset, ACL_READ))
+				acl_delete_perm(group_obj_permset, ACL_READ);
+			if (!acl_get_perm_np(mask_permset, ACL_WRITE))
+				acl_delete_perm(group_obj_permset, ACL_WRITE);
+			if (!acl_get_perm_np(mask_permset, ACL_EXECUTE))
+				acl_delete_perm(group_obj_permset, ACL_EXECUTE);
+		}
+	}
+
+	error = acl_get_entry(acl, ACL_FIRST_ENTRY, &ent);
+	while (error == 1) {
+		acl_get_tag_type(ent, &tag);
+		switch(tag) {
+			case ACL_USER:
+			case ACL_GROUP:
+			case ACL_MASK:
+				acl_delete_entry(acl, ent);
+				break;
+			default:
+				break;
+		}
+
+		error = acl_get_entry(acl, ACL_NEXT_ENTRY, &ent);
+	}
+	if (error < 0)
+		return -1;
+	return 0;
+}
+
+int
+strip_acl_posix1e(struct acl_info *w, FTSENT *fts_entry)
+{
+	/*
+	 * Convert non-trivial ACL to trivial ACL.
+	 * This function is only called when action is set
+	 * to 'strip'. A trivial ACL is one that is fully
+	 * represented by the posix mode. If the goal is to
+	 * simply remove ACLs, it will generally be more
+	 * efficient to strip the ACL using setfacl -b
+	 * from the root directory and then use the 'clone'
+	 * action to set the ACL recursively.
+	 */
+	char *path;
+	int ret;
+	struct acl_obj *theacl;
+	acl_t facl;
+
+	if (fts_entry == NULL)
+		path = w->path;
+	else
+		path = fts_entry->fts_accpath;
+
+	theacl = w->ops->get_acl_fn(w, fts_entry, true);
+	if (theacl->dacl != NULL) {
+		acl_free(theacl->dacl);
+		theacl->dacl = NULL;
+		ret = acl_delete_def_file(path);
+		if (ret != 0) {
+			fprintf(stdout, "Failed to remove default entries\n");
+			return -1;
+		}
+	}
+	facl = (acl_t)theacl->facl;
+	ret = remove_extended_entries(facl);
+	if (ret != 0) {
+		fprintf(stdout, "Failed to remove extended entries\n");
+		return -1;
+	}
+	ret = w->ops->set_acl_fn(w, fts_entry, theacl, true);
+	if (ret != 0) {
+		fprintf(stdout, "Failed to set new acl\n");
+		return -1;
+	}
+	w->ops->acl_free_fn(theacl);
+	if (w->uid != -1 || w->gid != -1) {
+		if (chown(path, w->uid, w->gid) < 0) {
+			warn("%s: chown() failed", path);
+			return (-1);
+		}
+	}
+	return (0);
+}
+
+/*
+ * Iterate through linked list of parent directories until we are able
+ * to find one that exists in the snapshot directory. Use this ACL
+ * to calculate an inherited acl.
+ */
+int get_acl_parent_posix1e(struct acl_info *w, FTSENT *fts_entry)
+{
+	int rval;
+	FTSENT *p = NULL;
+	FTSENT fake_ftsent;
+	char *relpath = NULL;
+	char shadow_path[PATH_MAX] = {0};
+	struct acl_obj *parent_acl = NULL;
+
+	if (fts_entry->fts_parent == NULL) {
+		/*
+		 * No parent node indicates we're at fts root level.
+		 */
+		ZERO_STRUCT(fake_ftsent);
+                fake_ftsent.fts_path = w->source;
+                fake_ftsent.fts_statp = &w->st;
+
+		parent_acl = w->ops->get_acl_fn(w, &fake_ftsent, true);
+		if (parent_acl == NULL) {
+			return -1;
+		}
+		rval = w->ops->calculate_inherited_acl_fn(w, parent_acl, 0);
+		if (rval != 0) {
+			warn("%s: acl_get_file() failed", w->source);
+		}
+		acl_free(parent_acl);
+		return rval;
+	}
+
+	for (p=fts_entry->fts_parent; p; p=p->fts_parent) {
+		rval = snprintf(shadow_path, sizeof(shadow_path),
+				"%s/%s", w->source, p->fts_accpath);
+		if (rval < 0) {
+			warn("%s: snprintf failed", relpath);
+			return -1;
+		}
+
+		parent_acl->dacl = acl_get_file(shadow_path, ACL_TYPE_DEFAULT);
+		if (parent_acl->dacl == NULL) {
+			if (errno == ENOENT) {
+				continue;
+			}
+			else {
+				warn("%s: acl_get_file() failed", shadow_path);
+				return -1;
+
+			}
+		}
+		parent_acl->facl = acl_get_file(shadow_path, ACL_TYPE_ACCESS);
+		if (parent_acl->facl == NULL) {
+			return -1;
+		}
+		rval = w->ops->calculate_inherited_acl_fn(w, parent_acl, 0);
+		if (rval == 0) {
+			acl_free(parent_acl);
+			return 0;
+		}
+		warn("%s: acl_get_file() failed", shadow_path);
+		acl_free(parent_acl);
+	}
+	return -1;
+}
+
+/*
+ * Compare two acl_t structs. Return 0 on success -1 on failure.
+ */
+#ifdef __linux__
+static int acl_cmp_internal(acl_t source, acl_t dest, int flags)
+{
+	return acl_cmp(source, dest);
+}
+#else
+static int acl_cmp_internal(acl_t source, acl_t dest, int flags)
+{
+	acl_entry_t s_entry, p_entry;
+	acl_permset_t s_perm, p_perm;
+	acl_tag_t s_tag, p_tag;
+	id_t *s_id, *p_id;
+
+	int entry_id = ACL_FIRST_ENTRY;
+	int rv;
+
+	while (acl_get_entry(source, entry_id, &s_entry) == 1) {
+		entry_id = ACL_NEXT_ENTRY;
+		rv = acl_get_entry(dest, entry_id, &p_entry);
+		if (rv != 1) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL_COUNT] ");
+			}
+			return -1;
+		}
+                acl_get_tag_type(s_entry, &s_tag);
+                acl_get_tag_type(p_entry, &p_tag);
+
+		if (s_tag != p_tag) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL tag 0x%08x -> 0x%08x] ",
+					s_tag, p_tag);
+			}
+			return -1;
+		}
+		s_id = acl_get_qualifier(s_entry);
+		p_id = acl_get_qualifier(p_entry);
+		if (*s_id != *p_id) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL id %d -> %d] ",
+					*s_id, *p_id);
+			}
+			return -1;
+		}
+
+		acl_get_permset(s_entry, &s_perm);
+		acl_get_permset(p_entry, &p_perm);
+		if (s_perm != p_perm) {
+			if (flags & WA_VERBOSE) {
+				fprintf(stdout, "+ [ACL perm 0x%08x -> 0x%08x] ",
+					s_perm, p_perm);
+			}
+			return -1;
+		}
+	}
+	return 0;
+}
+#endif
+
+int acl_cmp_posix1e(struct acl_obj source, struct acl_obj dest, int flags)
+{
+	int rv;
+	if ((source.dacl != NULL) && (dest.dacl != NULL)) {
+		rv = acl_cmp_internal(source.dacl, dest.dacl, flags);
+		if (rv != 0) {
+			return -1;
+		}
+		rv = acl_cmp_internal(source.facl, dest.facl, flags);
+		if (rv != 0) {
+			return -1;
+		}
+		return 0;
+	}
+	else if ((source.facl != NULL) && (dest.facl != NULL)) {
+		rv = acl_cmp_internal(source.facl, dest.facl, flags);
+		if (rv != 0) {
+			return -1;
+		}
+		return 0;
+	}
+	return -1;
+}
+
+static bool
+get_parent_path(char *dir)
+{
+	ptrdiff_t len;
+	char *p = NULL;
+	for (;;)
+	{
+		p = strrchr(dir, '/');
+		if (p == NULL) {
+			return false;
+		}
+		len = p-dir;
+		dir[len] = '\0';
+		if (access(dir, F_OK) == 0) {
+			break;
+		}
+	}
+	return true;
+}
+
+int
+restore_acl_posix1e(struct acl_info *w, char *relpath, FTSENT *fts_entry, size_t slen)
+{
+	int rval;
+	bool found_parent = false;
+	struct acl_obj *acl_new = NULL;
+	struct acl_obj *acl_old = NULL;
+	struct acl_obj *to_set = NULL;
+	FTSENT new;
+	char shadow_path[PATH_MAX] = {0};
+	char *tmp_name = NULL;
+
+	if (strlen(relpath) + slen > PATH_MAX) {
+		warn("%s: path in snapshot directory is too long", relpath);
+		return -1;
+	}
+
+	rval = snprintf(shadow_path, sizeof(shadow_path), "%s/%s", w->source, relpath);
+	if (rval < 0) {
+		warn("%s: snprintf failed", relpath);
+		return -1;
+	}
+	ZERO_STRUCT(new);
+	new.fts_path = shadow_path;
+	new.fts_statp = fts_entry->fts_statp; //we only care about whether this is a dir.
+	acl_new = w->ops->get_acl_fn(w, &new, true);
+	if (acl_new == NULL) {
+		if (errno == ENOENT) {
+			if (w->flags & WA_FORCE) {
+				tmp_name = strdup(shadow_path);
+				found_parent = get_parent_path(tmp_name);
+				if (!found_parent) {
+					free(tmp_name);
+					fprintf(stdout, "! %s\n", shadow_path);
+					return 0;
+				}
+				new.fts_path = tmp_name;
+				acl_new = w->ops->get_acl_fn(w, &new, true);
+				if (acl_new == NULL) {
+					warn("%s: OP_GET_ACL() failed", shadow_path);
+					free(tmp_name);
+					return -1;
+				}
+				free(tmp_name);
+				w->ops->calculate_inherited_acl_fn(w, acl_new, 0);
+				to_set = &w->acls[0];
+				//to_set = acl_new;
+			}
+			else {
+				fprintf(stdout, "! %s\n", shadow_path);
+				return 0;
+			}
+		}
+		else {
+			warn("%s: OP_GET_ACL() failed", shadow_path);
+			return (-1);
+		}
+	}
+	else {
+		to_set = acl_new;
+	}
+
+	acl_old = w->ops->get_acl_fn(w, fts_entry, true);
+	if (acl_old == NULL) {
+		warn("%s: OP_GETACL() failed", fts_entry->fts_path);
+		return (-1);
+	}
+
+	rval = w->ops->acl_cmp_fn(*to_set, *acl_old, w->flags);
+
+	if (rval == 0) {
+		return 0;
+	}
+
+	if (w->flags & WA_VERBOSE) {
+		fprintf(stdout, "%s -> %s\n",
+			shadow_path,
+			fts_entry->fts_path);
+	}
+	if ((w->flags & WA_TRIAL) == 0) {
+		rval = w->ops->set_acl_fn(w, fts_entry, to_set, true);
+		if (rval < 0) {
+			warn("%s: OP_SET_ACL() failed", fts_entry->fts_path);
+			w->ops->acl_free_fn(acl_old);
+			w->ops->acl_free_fn(acl_new);
+			return -1;
+		}
+	}
+
+	w->ops->acl_free_fn(acl_old);
+	w->ops->acl_free_fn(acl_new);
+	return 0;
+}
+
+struct acl_obj
+*get_acl_posix1e(struct acl_info *w, FTSENT *ftsentry, bool quiet)
+{
+	struct acl_obj *ret_acl = NULL;
+	ret_acl = calloc(1, sizeof(struct acl_obj));
+	if (ret_acl == NULL) {
+		return NULL;
+	}
+	ret_acl->facl = acl_get_file(ftsentry->fts_path, ACL_TYPE_ACCESS);
+	if (ret_acl->facl == NULL) {
+		if (!quiet) {
+			fprintf(stdout, "failed to get ACL on %s\n", ftsentry->fts_path);
+		}
+		free(ret_acl);
+		return NULL;
+	}
+	if (ISDIR(ftsentry)) {
+		ret_acl->dacl = acl_get_file(ftsentry->fts_path, ACL_TYPE_DEFAULT);
+		if (!quiet && ret_acl->dacl == NULL) {
+			fprintf(stdout, "failed to get DACL on %s\n", ftsentry->fts_path);
+			return NULL;
+		}
+	}
+	else {
+		ret_acl->dacl = NULL;
+	}
+	ret_acl->is_valid = true;
+	ret_acl->is_alloc = true;
+	return ret_acl;
+}
+
+int
+set_acl_posix1e(struct acl_info *w, FTSENT *fts_entry, struct acl_obj *theacl, bool quiet)
+{
+	char *path = NULL;
+	struct acl_obj *acl_new;
+	int acl_depth = 0;
+	if (!quiet && w->flags & WA_VERBOSE) {
+		fprintf(stdout, "%s\n", fts_entry->fts_path);
+	}
+
+	if (theacl != NULL) {
+		acl_new = theacl;
+	}
+	else if (fts_entry->fts_level == FTS_ROOTLEVEL) {
+		acl_new = w->source_acl;
+	}
+	else {
+		if ((fts_entry->fts_level -1) >= MAX_ACL_DEPTH) {
+			acl_depth = MAX_ACL_DEPTH-1;
+		}
+		else {
+			acl_depth = fts_entry->fts_level -1;
+		}
+		acl_new = &w->acls[acl_depth];
+	}
+
+	/* write out the acl to the file */
+	if (acl_set_file(fts_entry->fts_accpath, ACL_TYPE_ACCESS, acl_new->facl) < 0) {
+		warn("%s: acl_set_file() failed", path);
+		return (-1);
+	}
+	if (ISDIR(fts_entry) && (acl_set_file(fts_entry->fts_accpath, ACL_TYPE_DEFAULT, acl_new->facl)) < 0) {
+		warn("%s: acl_set_file() failed", path);
+		return (-1);
+	}
+
+	if (w->uid != -1 || w->gid != -1) {
+		if (chown(path, w->uid, w->gid) < 0) {
+			warn("%s: chown() failed", path);
+			return (-1);
+		}
+	}
+
+ 
+	return (0);
+}
+
+int
+calculate_inherited_acl_posix1e(struct acl_info *w, struct acl_obj *parent_acl, int level)
+{
+	if (parent_acl->dacl != NULL) {
+		w->acls[level].dacl = acl_dup(parent_acl->dacl);
+		if (w->acls[level].dacl == NULL) {
+			warn("acl_dup() failed");
+			w->acls[level].is_valid = false;
+			return -1;
+		}
+	}
+	if (parent_acl->facl != NULL) {
+		w->acls[level].facl = acl_dup(parent_acl->facl);
+		if (w->acls[level].facl == NULL) {
+			warn("acl_dup() failed");
+			w->acls[level].is_valid = false;
+			return -1;
+		}
+	}
+	w->acls[level].is_valid = true;
+	return 0;
+}
+
+void
+acl_free_posix1e(struct acl_obj *tofree)
+{
+	if (tofree == NULL || !tofree->is_valid) {
+		return;
+	}
+	if (tofree->is_valid && tofree->dacl != NULL) {
+		acl_free(tofree->dacl);
+	}
+	if (tofree->is_valid && tofree->facl != NULL) {
+		acl_free(tofree->facl);
+	}
+	tofree->is_valid = false;
+	if (tofree->is_alloc) {
+		free(tofree);
+		tofree = NULL;
+	}
+	return;
+}
+
+static const struct acl_ops posix1e_acl_ops = {
+	.restore_acl_fn = restore_acl_posix1e,
+	.calculate_inherited_acl_fn = calculate_inherited_acl_posix1e,
+	.set_acl_fn = set_acl_posix1e,
+	.get_acl_fn = get_acl_posix1e,
+	.get_acl_parent_fn = get_acl_parent_posix1e,
+	.strip_acl_fn = strip_acl_posix1e,
+	.acl_cmp_fn = acl_cmp_posix1e,
+	.acl_free_fn = acl_free_posix1e,
+};
+
diff --git a/source3/utils/wscript_build b/source3/utils/wscript_build
index 6157cac9050..66748c62f16 100644
--- a/source3/utils/wscript_build
+++ b/source3/utils/wscript_build
@@ -325,3 +325,14 @@ bld.SAMBA3_BINARY('mdfind',
                  RPCCLI_MDSSVC
                  mdssvc
                  ''')
+
+bld.SAMBA3_BINARY('acltool',
+                 source='''
+                 acltool.c
+                 acltool_posix1e.c
+                 acltool_nfs4.c
+                 ''',
+                 deps='''
+                 acl
+                 cmdline_contexts
+                 ''')
-- 
2.28.0

